---
title: "Project - GROUP3"
output: html_notebook
---

```{r setup, include=TRUE, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::knit_hooks$set(document = function(x) {
    paste(rapply(strsplit(x, '\n'), function(y) Filter(function(z) !grepl('# HIDE',z),y)), collapse ='\n')
})
```

## Part 1
### 1.1 - Load the data in R

```{r load functions, echo=FALSE}

# You must load the functions inside this chunk
source(paste(getwd(), '/src/utilities.R', sep = ""))
source(paste(getwd(), '/src/functions.R', sep = ""))

```


```{r load data}
DATA   <- read.table(getRawPath("E-GEOD-76987-raw-counts.tsv"), sep = "\t", row.names = 1, header = TRUE)
LABELS <- read.delim(getRawPath("labels.txt"), sep = "\t", header = TRUE)
```

### 1.2 - Calculate the sequencing depth of each sample

```{r calculate depth, results='hold', collapse=TRUE}
genes   <- DATA[,1]                 # name of the genes
samples <- DATA[,2:ncol(DATA)]      # samples in the datasets

genes_number   <- length(genes)     # it's the same of using -> nrow(samples)       
samples_number <- length(samples)   # it's the same of using -> ncol(samples)


# Computing the sequencing depth of each sample

depth <- apply(samples, 2, sum)     # 2 means that we're appling the sum by columns

{# HIDE
cat("Our dataset is composed by:\n\n")
cat(paste("♦", genes_number, "genes\n", sep = " "))           
cat(paste("♦", samples_number, "samples\n\n", sep = " "))          

cat("The sequencing depht of each sample is:\n", depth)

}# HIDE

```

### 1.3 - Produce the MvA plots of each sample vs. sample 1 (or another sample of your choice)

TODO: decide with respect to which sample we produce the plots and decide if remove the first column at the beginning or not

```{r generate temp dataset}
temp_samples <- samples + 1 # add 1 to all elements to avoid the log(0)
#TODO: save the temporary datasets into data/temp and reload it

extracted_index <- 1
    
interval <- (1:samples_number)[-extracted_index]
```

```{r produce MvA plots}
A <- matrix(0, nrow = genes_number, ncol = 0)
M <- matrix(0, nrow = genes_number, ncol = 0)

produceMvA(temp_samples, extracted_index, interval,  folder = "MvA", graph_title = "MvA Plot")
```

### 1.4 - Implement the TMM and the quantile normalization

```{r TMM Normalization Implementation}
tmm_normalization
```

```{r Quantile Normalization Implementation}
quantile_normalization
```

### 1.5 - Normalize the data using the method of your choice (explaining the reason of your choice)
```{r TMM Normalization}
A <- matrix(0, nrow = genes_number, ncol = 0)
M <- matrix(0, nrow = genes_number, ncol = 0)

tmm_normed <- tmm_normalization(temp_samples, extracted_index, interval)

```

```{r Quantile normalization}
A <- matrix(0, nrow = genes_number, ncol = 0)
M <- matrix(0, nrow = genes_number, ncol = 0)

quantile_normed <- quantile_normalization(temp_samples)

```

#### TODO: write which method we select and why

### 1.6 - Produce the MvA plots of each sample vs. sample 1 (or another sample of your choice) using normalized data to evaluate if the normalization step was correctly performed or if there are outlier sample.

```{r Produce Normalized MvA Plots}
# TMM Normalization 
produceMvA(tmm_normed$samples, extracted_index, interval,  folder = "MvA - TMM Normalization", graph_title = "MvA (TMM Normalization)")

# Quantile Normalization
produceMvA(quantile_normed$samples, extracted_index, interval,  folder = "MvA - Quantile Normalization", graph_title = "MvA (Quantile Normalization)")

#TODO: report the selected MVA plots and some comments on them
```
## Part 2

### Note 1 - There can be the same sample measured twice for a specific subject.

```{r remove of the duplicates}
normal <- LABELS[LABELS$sample_type == c("normal"),]            # get all the normal samples
unimuc <- LABELS[LABELS$sample_type == c("uninvolved mucosa"),] # get all the uninvolved mucosa samples

control <- rbind(normal, unimuc)                                # concatenate them 
control <- control[order(as.numeric(control$individual)),]        # sort in function of 'individual' value

disease <- LABELS[LABELS$sample_type == c("colon sessile serrated adenoma/polyp"),] # get all the disease samples

control_nodup <- remove_duplicates(quantile_normed$samples, control) # remove duplicates in control
disease_nodup <- remove_duplicates(quantile_normed$samples, disease) # remove duplicates in disease
```

### Note 2 - There can be some genes that in both groups 1 and 2 have always expression equal to 0.

```{r taking care of zeros}
groups_nozero <- remove_zeros(control_nodup, disease_nodup)
control_nodup_nozero<-groups_nozero$control
disease_nodup_nozero<-groups_nozero$disease
```

### 2.1 - Calculate p-values of DE analysis (not corrected for multiple testing) between the two groups using t-test, Wilcoxon test and edgeR.

```{r p-values}
Nc<-nrow(control_nodup_nozero)
c_ttest_pvalue <- NULL
c_wilcoxon_pvalue <- NULL

selected_ttest<-0
selected_wilcox<-0
for(i in (1:Nc)){ 
  c_ttest_pvalue <- c(c_ttest_pvalue,t.test(control_nodup_nozero[i,], disease_nodup_nozero[i,], var.equal = FALSE)$p.value)
  c_wilcoxon_pvalue <- c(c_wilcoxon_pvalue,wilcox.test(control_nodup_nozero[i,],disease_nodup_nozero[i,], exact=FALSE)$p.value)
}
```

TODO: controllare nomi variabili

```{r preprocessing}
#Rebuilt control matrix with initial data (not normalized)
control_nodup<-remove_duplicates(DATA,control)

count<-ncol(control_nodup)
nomi<-rep("", count)
for (i in (1:count))
{
  x<-paste("control",as.character(i),sep='_')
  nomi[i]<-x
}
colnames(control_nodup)<-nomi

#Rebuilt disease matrix with initial data (not normalized)

disease_nodup<-remove_duplicates(DATA,disease)

count<-ncol(disease_nodup)
nomi<-rep("", count)
for (i in (1:count))
{
  x<-paste("disease",as.character(i),sep='_')
  nomi[i]<-x
}
colnames(disease_nodup)<-nomi
```

TODO: controllare i commenti da lasciare, i nomi delle variabili e ciò da mostrare in output

```{r edgeR}
#unisco le due tabelle
mat <- cbind(disease_nodup, control_nodup)
library(edgeR)

# creo i gruppi che poi mi serviranno per definire "group"; di base mi serve solo che mi separino
#ciò che c'è in tabella in control e disease
#sono due vettori
gruppo_controllo <- rep("control",dim(control_nodup)[2])
gruppo_malato <- rep("disease",dim(disease_nodup)[2])

#li unisco, mi serve vettore unico per usare factor
gruppo <- cbind(t(as.data.frame(gruppo_malato)),t(as.data.frame(gruppo_controllo)))

#uso factor(), ottengo un oggetto diviso in due livelli (contorl e disease), come ci serve
group <- factor(gruppo)

#matrice di design
design <- model.matrix(~0+group) 
rownames(design) <- colnames(mat)  
print(design)

# fit values of phi (we need this step to fit our GLM model)
y <- DGEList(counts=mat, remove.zeros = TRUE)    # y is an object of type DGE
y <- calcNormFactors(y)   # This calculates the SF using the TMM normalization !!!
SF<-y$samples

y <- estimateGLMCommonDisp(y,design, verbose=TRUE) #phi common to the entire dataset
y <- estimateGLMTrendedDisp(y,design) #phi depends on mu
y <- estimateGLMTagwiseDisp(y,design) #phi is gene specific
fit <- glmFit(y,design) #finally the model fit (that accounts for raw NB data and scaling factors and seq. depth) 
summary(fit)

#il test
Confronti<-makeContrasts(Treatment=groupdisease-groupcontrol,levels=design)
RES<-glmLRT(fit,contrast=Confronti[,"Treatment"])

#alcuni output

# The first column of RES reports the log_Fold_Change, i.e.: 
# log2(Normalized_data_average_groupProvadisease / Normalized_data_average_groupProvacontrol)
RES$table[1:5,]

out <- topTags(RES, n = "Inf")$table
out[1:5,]
```

### 2.2 - Calculate the expected number of false positives (FP) and false negatives (FN) in correspondence to the choice of alpha = 0.05 and consider G0 = N with N being the number of genes.

```{r selection for alpha 0.05}
alpha<-0.05

lower<-(c_ttest_pvalue<alpha)
selected_ttest<-which(lower==TRUE)
num_sel_ttest<-length(selected_ttest)

lower<-(c_wilcoxon_pvalue<alpha)
selected_wilcox<-which(lower==TRUE)
num_sel_wilcox<-length(selected_wilcox)

#selected usando edgeR 
indSELedgeR<-length(which(out$PValue<alpha)) #i selected
```

```{r calculation of expected values}
G<-nrow(control_nodup_nozero)
G0<-G

#function that returns a vector with, in order, TP FP TN FN
expected_ttest <- expected_values(G, G0, alpha, num_sel_ttest)
expected_wilcoxontest <- expected_values(G, G0, alpha, num_sel_wilcox)
expected_edger <- expected_values(G, G0, alpha, indSELedgeR)
```

### 2.3 - Estimate the number of not differentially expressed genes G0 and re-estimate the expected number of false positives and false negatives.

``` {r estimation of G0 and re-estimation of the values for each test}
res <- estimateG0(c_ttest_pvalue, G0, "T test")
lambda_est_ttest <- 0.8
eps<-0.1
G0_est_ttest<-G0_value_estimation(lambda_est_ttest, eps, res)

expected_ttest_est <- expected_values(G, G0_est_ttest, alpha, num_sel_ttest)

res <- estimateG0(c_wilcoxon_pvalue, G0, "Wilcoxon test")
lambda_est_wilcoxon <- 0.8
eps<-0.1
G0_est_wilcoxontest<-G0_value_estimation(lambda_est_wilcoxon, eps, res)

expected_wilcoxontest_est <- expected_values(G, G0_est_wilcoxontest, alpha, num_sel_wilcox)

res <- estimateG0(out[,4], G0, "edgeR test")
lambda_est_edger <- 0.8
eps<-0.1
G0_est_edger<-G0_value_estimation(lambda_est_edger, eps, res)

expected_edgeR_est <- expected_values(G, G0_est_edger, alpha, indSELedgeR)
```

### 2.4 - Choose the “best” test among t-test, Wilcoxon test and edgeR motivating your choice.

TODO: write the motivations of edgeR

### 2.5 - Select the final list of DE genes using the test chosen at point 4 and a false discovery rate threshold of 5%.

```{r select the final list of DE genes}
FDR <- 0.05
#values observed as p-value in edgeR (chosen test)
lambda<-seq(min(out[,4]), max(out[,4]), (max(out[,4])-min(out[,4]))/nrow(out))
FDR_values<-NULL

for (i in (1:length(lambda))) {
  #compute FDR for every lambda
  minori<-(out[,4]<lambda[i])
  num_sel<-length(which(minori==TRUE))
  
  expected_val <- expected_values(G, G0_est_edger, lambda[i], num_sel)
  
  if (num_sel==0){
    FDR_values<-c(FDR_values,0)} 
  else {
    FDR_values<-c(FDR_values,(expected_val[2]/num_sel))}
}

plot(lambda,FDR_values)

#choose the values that are in [0.05-epsilon;0.05+espilon]
epsilon <- 0.0001
alpha_index <- which(FDR_values>=0.05-epsilon)
alpha_index2 <- which(FDR_values<=0.05+epsilon)
alpha_est <- mean(lambda[intersect(alpha_index,alpha_index2)])

indexes<-which(out$PValue<alpha_est) #the ones selected
index_genes_selected<-sort(as.numeric(rownames(out[indexes,])))

ID_genes_selected<-rownames(DATA[index_genes_selected,])
number_genes_selected<-length(ID_genes_selected)
ID_genes_notselected <- setdiff(rownames(DATA),ID_genes_selected)
number_genes_notselected<-length(ID_genes_notselected)
```

## Part 3

### 3.1 - extract G0 term associated 

```{r extract G0}

## ----- GESTIONE DEI NOMI DOPPI CON GENEID DIFFERENTI  --------------
#può andare bene?? NB: I NOMI SONO ANCHE DOPPI, MA GLI ENSEMBL (ENSG...) NON LO SONO
# 14 - estrazione di tutti i GOterm associati ai geni selezionati e creazione delle tabelle associate  

library(AnnotationDbi)
library(GO.db)
library(org.Hs.eg.db)

alldata <- select(org.Hs.eg.db, ID_genes_selected, columns = c("SYMBOL","ENTREZID", "ENSEMBL","GOALL"), keytype="ENSEMBL")
GOALL_NA<-which(is.na(alldata$GOALL))
#which(!(GOALL_NA==alldata$ONTOLOGYALL)) --> si nota che se NA su GOALL allora NA anche su ONTOLOGYALL 
ID_goall_na<-alldata$ENSEMBL[GOALL_NA]
GOALL_NA<-unique(GOALL_NA)

terms <- unique(alldata[,4])
terms <- terms[!is.na(terms)]

#QUESTO SOSTITUISCE I DUE CICLI FOR SUCCESSIVI, DA CAPIRE COSA TOGLIERE
ID_genes_selected_notna <- setdiff(ID_genes_selected,ID_goall_na)
number_genes_selected_notna <- length(ID_genes_selected_notna)
ID_genes_notselected_notna <- setdiff(ID_genes_notselected,ID_goall_na)
number_genes_notselected_notna <- length(ID_genes_notselected_notna)

#for(i in (1:length(GOALL_NA))){
#  term<-names_goall_na[i]
#  j<-0
#  l<-length(names_genes_selected)
#  while(l>0 && j<length(names_genes_selected))
#  {
#    j<-j+1
#    name_sel<-names_genes_selected[j]
#    if (term==name_sel)
#    {
#      names_genes_selected<-names_genes_selected[-j]
#      number_genes_selected<-number_genes_selected-1
#    }
#    l<-l-1
#  }
#}
#for(i in (1:length(GOALL_NA))){
#  term<-names_goall_na[i]
#  j<-0
#  l<-length(names_genes_notselected)
#  while(l>0 && j<length(names_genes_notselected))
#  {
#    j<-j+1
#    name_sel<-names_genes_notselected[j]
#    if (term==name_sel)
#    {
#      names_genes_notselected<-names_genes_notselected[-j]
#      number_genes_notselected<-number_genes_notselected-1
#    }
#    l<-l-1
#  }
#}

matrixes <- NULL

for (i in (1:length(terms))){
  GOterm <- terms[i]
  GOterm_indexes <- which(alldata$GOALL==GOterm)
  a <- length(intersect(alldata[GOterm_indexes,1],ID_genes_selected_notna))
  b <- number_genes_selected - a
  c <- length(GOterm_indexes) - a
  d <- length(ID_genes_notselected_notna)- c
  type<-alldata[(which(alldata[,4]==GOterm))[1],6]
  #matrice che ha nelle righe i GOterms associati e nelle colonne il tipo di GOterm e i valori di a,b,c,d per il fisher test 
  matrixes <- rbind(matrixes,c(type,a,b,c,d))
}

colnames(matrixes)<-c("type","a","b","c","d")
rownames(matrixes)<-terms
matrixes<-matrixes[order(rownames(matrixes)),]

```
### 3.2 - extract G0 term associated 

```{r fisher test}
15 - divisione delle tabelle per type e computazione del fisher test

matrixesCC <- matrixes[which(matrixes[,1]=="CC"),]
colnames(matrixesCC)<-c("type","a","b","c","d")
matrixesBP <- matrixes[which(matrixes[,1]=="BP"),]
colnames(matrixesBP)<-c("type","a","b","c","d")
matrixesMF <- matrixes[which(matrixes[,1]=="MF"),]
colnames(matrixesMF)<-c("type","a","b","c","d")

pval_fisherCC<-fisher_test_matrixes(matrixesCC)
pval_fisherBP<-fisher_test_matrixes(matrixesBP)
pval_fisherMF<-fisher_test_matrixes(matrixesMF)
```
### 3.3 - effettuare enrichment analysis or GSEA? (mi sa che ce la siamo persa)

## Part 4

```{r init clustering}
# 16 - lunghezza geni e clustering

#library(goseq)
#lengths_genes_selected<-getlength(ID_genes_selected, 'hg19', 'ensGene')
#l<-as.matrix(lengths_genes_selected)

library (EDASeq)
ensembl_list <- ID_genes_selected
d<-getGeneLengthAndGCContent(ensembl_list, "hsa")
#d[[1]] contiene le lunghezz dei geni

data_normalized<-DATA[,-1]
data_normalized<-data_normalized[index_genes_selected,]
data_normalized<-t(t(data_normalized)/d[[1]])

# da qui in avanti non ci sono gli oggetti nel dataset salvato

# 17 - clustering

## IDEA
# FACENDO CLUSTERING DEI GENES MI ASPETTO CHE IL CLUSTER SIA 1 O COMUNQUE POCHI CLUSTERS.... SE SONO TUTTI 
# I SELEZIONATI NON DOVREI VEDERE DIFFERENZE TRA LORO, SONO TUTTI ASSOCIATI ALLA MALATTIA

# FACENDO CLUSTERING DEI SAMPLES, DOVREI VEDERE CHE SI DIVIDONO IN DUE CLASSI, MALATI E SANI
# BISOGNA RICONSIDERARE I SAMPLES CAMPIONATI DUE VOLTE?


dataNorm_nodup_control<-remove_duplicates(data_normalized,control) 
dataNorm_nodup_disease<-remove_duplicates(data_normalized,disease) 

dataNorm_clustering<-cbind(dataNorm_nodup_control,dataNorm_nodup_disease)
```

### 1. Cluster the genes you have selected in exercise 2 using k-means and hierarchical clustering and compare the results you obtain.

```{r clustering genes}
#CLUSTERING GENES kmeans

K<-seq(1,3,by=1)
WITHIN_SS<-NULL
clus_km<-NULL
sk <- NULL
for(i in (1:length(K)))
{
  k_i<-K[i]
  cl_kmeans_genes<-kmeans(x=dataNorm_clustering,centers=k_i,iter.max=100,nstart=1)
  clus_km<-c(clus_km,cl_kmeans_genes)
  WITHIN_SS<-rbind(WITHIN_SS, cl_kmeans_genes$tot.withinss)
  sk <- rbind(sk, silhouette(dataNorm_clustering,cl_kmeans_genes[[1]], k_i))
}
print(sk)
cat("K-Means over samples!\n")
print(sk)
cat(max(sk), " - optimal number of clusters is :", K[which(sk == max(sk))])
plot(K, WITHIN_SS)


#CLUSTERING GENES hierachical
D<-dist(dataNorm_clustering) #D is an object of class "dist". To get a matrix one needs to use "as.matrix(D)"


# USIAMO WARD PERCHè SFRUTTA DISTANZA EUCLIDEA E CPSì LO COMPARIAMO BENE CON KMEANS CHE USA SEMPRE LA EUCLIDEA
cl_hclust_ward<-hclust(d=D,method="ward.D2")
plot(cl_hclust_ward, hang=-1) 

sk <- NULL
K<-seq(1,10,by=1)
for (i in (1:length(K))){
  k <- K[i]
  clusters_hclust_ward<-cutree(cl_hclust_ward, k=k)
  sk <- c(sk,silhouette(dataNorm_clustering,clusters_hclust_ward,k))
  #print("i: ",i," - sk: ",sk)
}
cat("Hierarchial clusters over genes!\n")
print(sk)
cat(max(sk), " - optimal number of clusters is :", K[which(sk == max(sk))])



```


2. Cluster the samples in your dataset (considering only the genes you have selected in exercise 2) using k-means and hierarchical clustering and compare the results you obtain

```{r clustering samples}
#CLUSTERING SAMPLES kmeans
K<-seq(1,10,by=1)
WITHIN_SS_sample<-NULL
clus_km_sample<-NULL
sk <- NULL
for(i in (1:length(K))) {
  k_i<-K[i]
  cl_kmeans_samples<-kmeans(x=t(dataNorm_clustering),centers=k_i,iter.max=100,nstart=100)
  clus_km_sample<-c(clus_km_sample,cl_kmeans_samples)
  WITHIN_SS_sample<-rbind(WITHIN_SS_sample, cl_kmeans_samples$tot.withinss)
  sk <- rbind(sk, silhouette(t(dataNorm_clustering),cl_kmeans_samples[[1]], k_i))
}
cat("K-Means over samples!\n")
print(sk)
cat(max(sk), " - optimal number of cluster is :", K[which(sk == max(sk))])
plot(K, WITHIN_SS_sample)

#CLUSTERING SAMPLES hierachical
D<-dist(t(dataNorm_clustering))  #D is an object of class "dist". To get a matrix one needs to use "as.matrix(D)"

cl_hclust_ward_S<-hclust(d=D,method="ward.D2")
plot(cl_hclust_ward_S, hang=-1) 

sk <- NULL
K<-seq(1,10,by=1)
for (i in (1:length(K))){
  k <- K[i]
  clusters_hclust_ward_S<-cutree(cl_hclust_ward_S, k=k)
  sk <- c(sk,silhouette(t(dataNorm_clustering),clusters_hclust_ward_S,k))
}
cat("Hierarchial clusters over samples!\n")
print(sk)
cat(max(sk), " - optimal number of clusters is :", K[which(sk == max(sk))])

```
3. Choose the optimal number of clusters using the silhouette statistic. Do not use available R functions, I want you to implement it.

```{r silhouette implementation}
silhouette
```
4. Choose the optimal number of clusters using the Gap statistic. In this case you can use the R function clusGap() in the library “cluster”

```{r gap}
#GAP STATISTIC 
library(cluster)

test_hclust <- function(x, k) list(cluster=cutree(hclust(dist(x), method = "average"),k=k))

#SAMPLES
prova<-clusGap(t(dataNorm_clustering), test_hclust, length(K), B=100)

for (i in (2:(nrow(prova[[1]])-1))){
  if (prova[[1]][i,3]>prova[[1]][i+1,3]+prova[[1]][i+1,4])
    break;
}
cat("Numero ottimo per hierachical clustering dei samples secondo Gap Statistics: ",i)

#GENES
prova<-clusGap(dataNorm_clustering, test_hclust, length(K), B=100)

for (i in (1:(nrow(prova[[2]])-1))){
  if (prova[[1]][i,3]>prova[[1]][i+1,3]+prova[[1]][i+1,4])
    break;
}
cat("Numero ottimo per hierachical clustering dei geni secondo Gap Statistics: ",i)

# ---------------

#SAMPLES

test_kmeans <- function(x, k) (kmeans(x=x,centers=k,iter.max=100,nstart=100))

prova<-clusGap(t(dataNorm_clustering), test_kmeans, length(K), B=100)

for (i in (2:(nrow(prova[[1]])-1))){
  if ((prova[[1]][i,3])>(prova[[1]][i+1,3]+prova[[1]][i+1,4]))
    break;
}
cat("Numero ottimo per kmeans dei samples secondo Gap Statistics: ",i)

#GENES

prova<-clusGap(dataNorm_clustering, test_kmeans, length(K), B=2)

for (i in (2:(nrow(prova[[1]])-1))){
  if ((prova[[1]][i,3])>(prova[[1]][i+1,3]+prova[[1]][i+1,4]))
    break;
}
cat("Numero ottimo per kmeans dei geni secondo Gap Statistics: ",i)
```

## Part 5